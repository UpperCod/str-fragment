{"version":3,"file":"index.js","sources":["../src/utils.js","../src/index.js"],"sourcesContent":["/**\n *\n * @typedef {Object} CallbackParam\n * @property {string} body\n * @property {string} content\n * @property {import(\"./internal\").Item} open\n * @property {import(\"./internal\").Item} end\n */\n\n/**\n * @param {string} text\n * @param {number} diff\n * @param {import(\"./internal\").Block} block\n * @param {(param:CallbackParam)=>string} callback\n */\nfunction replaceItem(text, diff, { open, end }, callback) {\n    let before = text.slice(0, open.indexOpen + diff);\n    let after = text.slice(end.indexEnd + diff);\n    let body = text.slice(open.indexOpen + diff, end.indexEnd + diff);\n    let content = text.slice(open.indexEnd + diff, end.indexOpen + diff);\n    let nextContent = callback({ body, content, open, end }) + \"\";\n    diff += nextContent.length - body.length;\n    text = before + nextContent + after;\n    return { diff, text };\n}\n\n/**\n *\n * @param {string} text\n * @param {import(\"./internal\").Block[]} blocks\n * @param {(param:CallbackParam)=>string} callback\n * @param {number} [limit=-1]\n * @returns {string}\n */\nexport function replaceFragments(text, blocks, callback, limit = -1) {\n    let diff = 0;\n    for (let i = 0; i < blocks.length; i++) {\n        let res = replaceItem(text, diff, blocks[i], callback);\n        diff = res.diff;\n        text = res.text;\n        if (limit == i + 1) break;\n    }\n    return text;\n}\n\n/**\n *\n * @param {string} text\n * @param {import(\"./internal\").Block[]} blocks\n * @param {(param:CallbackParam)=>string} callback\n * @param {number} [limit=-1]\n * @returns {void}\n */\nexport function walkFragments(text, blocks, callback, limit = -1) {\n    replaceFragments(\n        text,\n        blocks,\n        (param) => {\n            callback(param);\n            return param.body;\n        },\n        limit\n    );\n}\n","export * from \"./utils\";\n/**\n *\n * @param {string} text\n * @param {RegExp} reg\n */\nfunction find(text, reg) {\n    let current;\n    let position = 0;\n    /**@type {import(\"./internal\").Item[]} */\n    let items = [];\n    while ((current = text.match(reg))) {\n        let [value, ...args] = current;\n        let length = current.index + value.length;\n        if (!length) break;\n        items.push({\n            value,\n            args,\n            indexOpen: position + current.index,\n            indexEnd: position + length,\n        });\n        position += length;\n        text = text.slice(length);\n    }\n    return items;\n}\n/**\n *\n * @param {string} text\n * @param {{open:RegExp,end:RegExp,equal:boolean}} find\n */\nexport function getFragments(text, { open, end, equal }) {\n    let itemsOpen = find(text, open);\n    let itemsEnd = find(text, end);\n\n    let itemOpen;\n    /**@type {import(\"./internal\").Block[]} */\n    let blocks = [];\n\n    itemsEnd = equal\n        ? itemsEnd\n        : itemsEnd.filter(\n              (block) =>\n                  !itemsOpen.some(\n                      ({ indexOpen, indexEnd }) =>\n                          block.indexOpen >= indexOpen &&\n                          block.indexOpen <= indexEnd\n                  )\n          );\n\n    while ((itemOpen = itemsOpen.pop())) {\n        let nextItemsEnd = [...itemsEnd];\n        let itemEnd;\n        itemsEnd = [];\n        while ((itemEnd = nextItemsEnd.shift())) {\n            if (itemEnd.indexOpen > itemOpen.indexEnd) {\n                blocks.unshift({ open: itemOpen, end: itemEnd });\n                itemsEnd.push(...nextItemsEnd);\n                break;\n            } else {\n                itemsEnd.push(itemEnd);\n            }\n        }\n    }\n\n    let parentBlock;\n\n    return blocks.filter((block) => {\n        if (!parentBlock) {\n            parentBlock = block;\n            return true;\n        }\n        if (\n            block.open.indexOpen > parentBlock.open.indexOpen &&\n            block.end.indexEnd < parentBlock.end.indexEnd\n        ) {\n            return false;\n        } else {\n            parentBlock = block;\n            return true;\n        }\n    });\n}\n"],"names":[],"mappings":"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"}